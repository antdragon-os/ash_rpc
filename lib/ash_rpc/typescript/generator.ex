defmodule AshRpc.TypeScript.Generator do
  @moduledoc """
  Core TypeScript generation module for ash_rpc.

  This module orchestrates the generation of TypeScript types and schemas
  from Ash resources, providing a clean interface for the Mix task.
  """

  alias AshRpc.TypeScript.{SchemaGenerator, TypeInference, ZodGenerator, ResourceUtils, TypeUtils}

  @doc """
  Generates complete TypeScript types for the given domains.
  """
  def generate_types(domains) do
    # Precompute field aliases for all exposed resources
    resources_for_aliases = ResourceUtils.get_resources_for_aliases(domains)

    field_aliases =
      resources_for_aliases |> Enum.map(&SchemaGenerator.generate_fields_alias/1) |> Enum.join("\n")

    nested_aliases =
      resources_for_aliases
      |> Enum.map(&SchemaGenerator.generate_nested_query_alias/1)
      |> Enum.join("\n")

    blocks = generate_domain_blocks(domains)

    """
    import type * as _trpc_server from '@trpc/server';
    import type * as _trpc_server_dist_unstable_core_do_not_import from "@trpc/server/unstable-core-do-not-import";
    // generated by mix ash.trpc.gen

    // Local resource schema definitions for dynamic field selection
    #{resources_for_aliases |> Enum.map(&SchemaGenerator.generate_resource_schema_definition/1) |> Enum.join("\n")}

    // Utility Types for Dynamic Field Selection
    #{TypeInference.utility_types()}

    // Strongly-typed field aliases per resource
    #{field_aliases}
    // Strongly-typed nested query option types per resource
    #{nested_aliases}
    export declare const appRouter: _trpc_server_dist_unstable_core_do_not_import.BuiltRouter<{
      ctx: Record<string, unknown>;
      meta: object;
      errorShape: {
        data: {
          code: _trpc_server_dist_unstable_core_do_not_import.TRPC_ERROR_CODE_KEY;
          httpStatus: number;
          path?: string;
          stack?: string;
          formErrors?: Record<string, string[]>;
          details?: Array<{
            type: string;
            message: string;
            details?: {
              class: string;
              path: string[];
              errors: Array<{
                type: string;
                message: string;
              }>;
            };
          }>;
        };
        message: string;
        code: _trpc_server_dist_unstable_core_do_not_import.TRPC_ERROR_CODE_NUMBER;
      };
      transformer: true;
    }, _trpc_server_dist_unstable_core_do_not_import.DecorateCreateRouterOptions<{
    #{blocks}
    }>>;
    export type AppRouter = typeof appRouter;
    """
  end

  @doc """
  Generates Zod schemas for the given domains.
  """
  def generate_zod_schemas(domains) do
    header = """
    // generated by mix ash.trpc.gen --zod
    import { z } from 'zod';
    """

    # Generate nested structure
    domain_blocks =
      Enum.map(domains, fn domain ->
        domain_name = ResourceUtils.domain_segment(domain)

        resources =
          Ash.Domain.Info.resources(domain)
          |> Enum.filter(&ResourceUtils.exposed_resource?/1)

        resource_blocks =
          Enum.map(resources, fn resource ->
            resource_name = ResourceUtils.resource_segment(resource)
            schemas = ZodGenerator.generate_domain_schemas_for_resource(resource)

            if schemas != [] do
              schema_lines = Enum.map(schemas, fn schema -> "      #{schema}" end)
              "#{resource_name}: {\n#{Enum.join(schema_lines, ",\n")}\n    }"
            else
              nil
            end
          end)
          |> Enum.reject(&is_nil/1)

        if resource_blocks != [] do
          "export const #{domain_name} = {\n#{Enum.join(resource_blocks, ",\n")}\n};"
        else
          nil
        end
      end)
      |> Enum.reject(&is_nil/1)

    body =
      if domain_blocks == [] do
        ""
      else
        "\n" <> Enum.join(domain_blocks, "\n\n") <> "\n"
      end

    header <> body
  end

  defp generate_domain_blocks(domains) do
    domains
    |> Enum.map(fn domain ->
      resources = Ash.Domain.Info.resources(domain)
      dom_seg = ResourceUtils.domain_segment(domain)

      res_blocks =
        resources
        |> Enum.filter(&ResourceUtils.exposed_resource?/1)
        |> Enum.group_by(&ResourceUtils.resource_segment/1)
        |> Enum.map(fn {seg, [res | _]} ->
          generate_resource_block(res, seg)
        end)
        |> Enum.join("\n")

      "  #{dom_seg}: {\n#{res_blocks}\n  };"
    end)
    |> Enum.join("\n")
  end

  defp generate_resource_block(resource, seg) do
    procedures = ResourceUtils.safe_procedures(resource)

    specs =
      if procedures == [] do
        resource
        |> Ash.Resource.Info.actions()
        |> Enum.filter(&ResourceUtils.exposed_action?(resource, &1))
        |> Enum.map(fn act ->
          %{
            name: act.name,
            action: act.name,
            method: TypeUtils.method_override_or_default(resource, act),
            filterable: true,
            sortable: true,
            selectable: true,
            paginatable: true,
            relationships: nil
          }
        end)
      else
        Enum.map(procedures, fn p ->
          %{
            name: p.name,
            action: p.action,
            method: p.method,
            filterable: Map.get(p, :filterable, true),
            sortable: Map.get(p, :sortable, true),
            selectable: Map.get(p, :selectable, true),
            paginatable: Map.get(p, :paginatable, true),
            relationships: Map.get(p, :relationships, nil)
          }
        end)
      end

    action_ts =
      specs
      |> Enum.map(fn spec ->
        generate_action_type(resource, spec)
      end)
      |> Enum.join("\n")

    "    #{seg}: {\n#{action_ts}\n    };"
  end

  defp generate_action_type(resource, spec) do
    act = Ash.Resource.Info.action(resource, spec.action)
    name = TypeUtils.camelize_lower(spec.name)

    cond do
      is_nil(act) ->
        proc =
          case spec.method do
            :query -> "_trpc_server.TRPCQueryProcedure"
            :mutation -> "_trpc_server.TRPCMutationProcedure"
          end

        "      #{name}: #{proc}<{input: void; output: unknown; meta: object }>;"

      true ->
        {base_output, is_infinite_query} = get_output_type(resource, act, spec)

        output = get_response_type(base_output, act, spec, is_infinite_query)

        proc =
          case spec.method do
            :query -> "_trpc_server.TRPCQueryProcedure"
            :mutation -> "_trpc_server.TRPCMutationProcedure"
          end

        fields_alias = SchemaGenerator.fields_alias_name(resource)
        input_type = TypeUtils.ts_action_input_with_query(resource, act, spec)
        input_with_fields = String.replace(input_type, "AshFields", fields_alias)

        "      #{name}: #{proc}<{input: #{input_with_fields}; output: #{output}; meta: object }>;"
    end
  end

  defp get_output_type(resource, act, _spec) do
    case act.type do
      :read ->
        if Map.get(act, :get?, false) do
          {SchemaGenerator.resource_shape_with_fields(resource), false}
        else
          # Array read actions support infinite queries
          {SchemaGenerator.resource_shape_with_fields(resource) <> "[]", true}
        end

      :destroy ->
        {"{}", false}

      :action ->
        {"unknown", false}

      _ ->
        {SchemaGenerator.resource_shape_with_fields(resource), false}
    end
  end

  defp get_response_type(base_output, act, spec, is_infinite_query) do
    cond do
      is_infinite_query ->
        # Infinite queries only support keyset pagination
        "AshInfiniteQueryResponse<#{base_output}>"

      act.type == :read && spec[:paginatable] != false ->
        # Regular paginated queries support both offset and keyset
        "AshPaginatedQueryResponse<#{base_output}>"

      true ->
        # Non-paginated queries
        "AshQueryResponse<#{base_output}>"
    end
  end
end
